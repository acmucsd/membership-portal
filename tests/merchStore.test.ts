import * as faker from 'faker';
import { ForbiddenError } from 'routing-controllers';
import { zip } from 'underscore';
import { anything, mock, when } from 'ts-mockito';
import { OrderModel } from '../models/OrderModel';
import { MerchandiseItemOptionModel } from '../models/MerchandiseItemOptionModel';
import { MerchItemEdit, UserAccessType } from '../types';
import { ControllerFactory } from './controllers';
import { DatabaseConnection, MerchFactory, PortalState, UserFactory } from './data';
import EmailService from '../services/EmailService';

beforeAll(async () => {
  await DatabaseConnection.connect();
});

beforeEach(async () => {
  await DatabaseConnection.clear();
});

afterAll(async () => {
  await DatabaseConnection.clear();
  await DatabaseConnection.close();
});

describe('merch store permissions', () => {
  test('members can only access store with a valid acm or ucsd email', async () => {
    const conn = await DatabaseConnection.get();
    const UCSDMember = UserFactory.fake({ credits: 10000 });
    const ACMBoardMember = UserFactory.fake({
      email: 'random@acmucsd.org',
      credits: 10000,
    });
    const invalidMember = UserFactory.fake({
      email: 'random@gmail.com',
      credits: 10000,
    });

    const affordableOption1 = MerchFactory.fakeOption({
      quantity: 5,
      price: 2000,
      discountPercentage: 0,
    });
    const pickupEvent = MerchFactory.fakeFutureOrderPickupEvent();

    await new PortalState()
      .createUsers(ACMBoardMember, UCSDMember, invalidMember)
      .createMerchItemOptions(affordableOption1)
      .createOrderPickupEvents(pickupEvent)
      .write();

    const merchStoreController = await ControllerFactory.merchStore(conn);

    const ACMBoardMemberResponse = await merchStoreController.getAllMerchCollections(ACMBoardMember);
    expect(ACMBoardMemberResponse.error).toBe(null);

    const UCSDMemberResponse = await merchStoreController.getAllMerchCollections(UCSDMember);
    expect(UCSDMemberResponse.error).toBe(null);

    expect(merchStoreController.getAllMerchCollections(invalidMember)).rejects.toThrow(ForbiddenError);
  });

  test('archived collections are hidden from members, but not for store managers', async () => {
    const conn = await DatabaseConnection.get();
    const storeManager = UserFactory.fake({ accessType: UserAccessType.MERCH_STORE_MANAGER });
    const member = UserFactory.fake({ accessType: UserAccessType.STANDARD });
    const archivedCollection = MerchFactory.fakeCollection({
      archived: true,
    });
    const unarchivedCollection = MerchFactory.fakeCollection({
      archived: false,
    });

    await new PortalState()
      .createUsers(storeManager, member)
      .createMerchCollections(archivedCollection, unarchivedCollection)
      .write();

    const merchStoreController = ControllerFactory.merchStore(conn);

    const collectionsVisibleByManager = await merchStoreController.getAllMerchCollections(storeManager);
    expect(collectionsVisibleByManager.collections.map((c) => c.uuid)).toEqual(
      expect.arrayContaining([archivedCollection.uuid, unarchivedCollection.uuid]),
    );

    const collectionsVisibleByMember = await merchStoreController.getAllMerchCollections(member);
    expect(collectionsVisibleByMember.collections.map((c) => c.uuid)).toEqual(
      expect.arrayContaining([unarchivedCollection.uuid]),
    );
  });

  test('hidden items are hidden from members, but not for store managers', async () => {
    const conn = await DatabaseConnection.get();
    const storeManager = UserFactory.fake({ accessType: UserAccessType.MERCH_STORE_MANAGER });
    const member = UserFactory.fake({ accessType: UserAccessType.STANDARD });
    const hiddenItem = MerchFactory.fakeItem({
      hidden: true,
    });
    const visibleItem = MerchFactory.fakeItem({
      hidden: false,
    });
    const collection = MerchFactory.fakeCollection({
      items: [hiddenItem, visibleItem],
    });

    await new PortalState()
      .createUsers(storeManager, member)
      .createMerchCollections(collection)
      .write();

    const merchStoreController = ControllerFactory.merchStore(conn);

    const collectionsForManagerResponse = await merchStoreController.getAllMerchCollections(storeManager);
    const itemsForManager = collectionsForManagerResponse.collections[0].items.map((i) => i.uuid);
    expect(itemsForManager).toEqual(expect.arrayContaining([visibleItem.uuid, hiddenItem.uuid]));

    const collectionsForMemberResponse = await merchStoreController.getAllMerchCollections(storeManager);
    const itemsForMember = collectionsForMemberResponse.collections[0].items.map((i) => i.uuid);
    expect(itemsForMember).toEqual(expect.arrayContaining([visibleItem.uuid]));
  });
});

describe('creating merch collections', () => {
  test('getting created collections returns them in reverse order of creation', async () => {
    const conn = await DatabaseConnection.get();
    const admin = UserFactory.fake({ accessType: UserAccessType.ADMIN });
    const member = UserFactory.fake({ accessType: UserAccessType.STANDARD });
    const firstCollectionToBeMade = MerchFactory.fakeCollection({
      createdAt: faker.date.past(),
      archived: true,
    });
    const secondCollectionToBeMade = MerchFactory.fakeCollection({
      createdAt: new Date(),
      archived: false,
    });
    const thirdCollectionToBeMade = MerchFactory.fakeCollection({
      createdAt: faker.date.future(),
      archived: false,
    });

    await new PortalState()
      .createUsers(admin, member)
      .createMerchCollections(firstCollectionToBeMade, secondCollectionToBeMade, thirdCollectionToBeMade)
      .write();

    const merchStoreController = ControllerFactory.merchStore(conn);

    const expectedCollectionOrder = [thirdCollectionToBeMade, secondCollectionToBeMade]
      .map((coll) => coll.uuid);

    const collectionsVisibleByAdmin = await merchStoreController.getAllMerchCollections(admin);

    expect(collectionsVisibleByAdmin.collections.map((collection) => collection.uuid))
      .toEqual(expectedCollectionOrder.concat(firstCollectionToBeMade.uuid));

    const collectionsVisibleByMember = await merchStoreController.getAllMerchCollections(member);

    expect(collectionsVisibleByMember.collections.map((collection) => collection.uuid))
      .toEqual(expectedCollectionOrder);
  });
});
describe('editing merch collections', () => {
  test('only admins can edit merch collections', async () => {
    const conn = await DatabaseConnection.get();
    const admin = UserFactory.fake({ accessType: UserAccessType.ADMIN });
    const member = UserFactory.fake({ accessType: UserAccessType.STANDARD });
    const collection = MerchFactory.fakeCollection();

    await new PortalState()
      .createUsers(admin, member)
      .createMerchCollections(collection)
      .write();

    const merchStoreController = ControllerFactory.merchStore(conn);
    const params = { uuid: collection.uuid };
    const editMerchCollectionRequest = { collection: { title: faker.datatype.hexaDecimal(10) } };

    await expect(merchStoreController.editMerchCollection(params, editMerchCollectionRequest, member))
      .rejects.toThrow(ForbiddenError);

    const editMerchCollectionResponse = await merchStoreController
      .editMerchCollection(params, editMerchCollectionRequest, admin);
    expect(editMerchCollectionResponse.collection.uuid).toEqual(collection.uuid);
    expect(editMerchCollectionResponse.collection.title).toEqual(editMerchCollectionRequest.collection.title);
  });
});

describe('archived merch collections', () => {
  test('only admins can view archived collections', async () => {
    const conn = await DatabaseConnection.get();
    const admin = UserFactory.fake({ accessType: UserAccessType.ADMIN });
    const member = UserFactory.fake({ accessType: UserAccessType.STANDARD });
    const collection = MerchFactory.fakeCollection({ archived: true });

    await new PortalState()
      .createUsers(admin, member)
      .createMerchCollections(collection)
      .write();

    const merchStoreController = ControllerFactory.merchStore(conn);
    const params = { uuid: collection.uuid };

    await expect(merchStoreController.getOneMerchCollection(params, member))
      .rejects.toThrow(ForbiddenError);

    const getMerchCollectionResponse = await merchStoreController.getOneMerchCollection(params, admin);
    expect(getMerchCollectionResponse.collection.uuid).toEqual(collection.uuid);
  });
});

describe('merch items with options', () => {
  test('monthly and lifetime remaining values are properly set when ordering different item options', async () => {
    const conn = await DatabaseConnection.get();
    const member = UserFactory.fake();
    const optionMetadataType = faker.datatype.hexaDecimal(10);
    const option1 = MerchFactory.fakeOptionWithType(optionMetadataType);
    const option2 = MerchFactory.fakeOptionWithType(optionMetadataType);
    const option3 = MerchFactory.fakeOptionWithType(optionMetadataType);
    const unorderedOption = MerchFactory.fakeOption();
    const item = MerchFactory.fakeItem({
      options: [option1, option2, option3],
      monthlyLimit: 5,
      lifetimeLimit: 10,
    });
    const unorderedItem = MerchFactory.fakeItem({
      options: [unorderedOption],
      hasVariantsEnabled: false,
      monthlyLimit: 5,
      lifetimeLimit: 10,
    });
    const pickupEvent = MerchFactory.fakeFutureOrderPickupEvent();

    await new PortalState()
      .createUsers(member)
      .createMerchItem(item)
      .createMerchItem(unorderedItem)
      .createOrderPickupEvents(pickupEvent)
      .orderMerch(member, [
        { option: option1, quantity: 1 },
        { option: option2, quantity: 1 },
        { option: option3, quantity: 1 },
      ], pickupEvent)
      .write();

    const merchStoreController = ControllerFactory.merchStore(conn);
    const orderedItemParams = { uuid: item.uuid };
    const getOrderedItemResponse = await merchStoreController.getOneMerchItem(orderedItemParams, member);
    const updatedItem = getOrderedItemResponse.item;

    // make sure the ordered item's remaining counts got updated
    expect(updatedItem.monthlyRemaining).toEqual(2);
    expect(updatedItem.lifetimeRemaining).toEqual(7);

    const unorderedItemParams = { uuid: unorderedItem.uuid };
    const getUnorderedItemResponse = await merchStoreController.getOneMerchItem(unorderedItemParams, member);
    const unchangedItem = getUnorderedItemResponse.item;

    // make sure the un-ordered item's remaining counts didn't change
    expect(unchangedItem.monthlyRemaining).toEqual(5);
    expect(unchangedItem.lifetimeRemaining).toEqual(10);
  });

  test('monthly and lifetime remaining values are reset when an order is cancelled', async () => {
    const conn = await DatabaseConnection.get();
    const member = UserFactory.fake();
    const option = MerchFactory.fakeOption();
    const item = MerchFactory.fakeItem({
      options: [option],
      monthlyLimit: 5,
      lifetimeLimit: 10,
    });
    const pickupEvent = MerchFactory.fakeFutureOrderPickupEvent();

    await new PortalState()
      .createUsers(member)
      .createMerchItem(item)
      .createOrderPickupEvents(pickupEvent)
      .orderMerch(member, [
        { option, quantity: 1 },
      ], pickupEvent)
      .write();

    const emailService = mock(EmailService);
    when(emailService.sendOrderCancellation(member.email, member.firstName, anything()))
      .thenResolve();

    // make sure the item's remaining counts got updated
    const merchStoreController = ControllerFactory.merchStore(conn);
    const orderedItemParams = { uuid: item.uuid };
    const getOrderedItemResponse = await merchStoreController.getOneMerchItem(orderedItemParams, member);
    const updatedItem = getOrderedItemResponse.item;
    expect(updatedItem.monthlyRemaining).toEqual(4);
    expect(updatedItem.lifetimeRemaining).toEqual(9);

    // cancel order
    const order = await conn.manager.findOne(OrderModel, { user: member });
    const cancelOrderParams = { uuid: order.uuid };
    await merchStoreController.cancelMerchOrder(cancelOrderParams, member);

    // make sure the item's remaining counts got reset
    const getCancelledItemResponse = await merchStoreController.getOneMerchItem(orderedItemParams, member);
    const cancelledItem = getCancelledItemResponse.item;
    expect(cancelledItem.monthlyRemaining).toEqual(5);
    expect(cancelledItem.lifetimeRemaining).toEqual(10);
  });
});

describe('merch items with no options', () => {
  test('can delete all item options and add back options if the item is hidden', async () => {
    const conn = await DatabaseConnection.get();
    const admin = UserFactory.fake({ accessType: UserAccessType.ADMIN });
    const item = MerchFactory.fakeItem({ hidden: true });

    await new PortalState()
      .createUsers(admin)
      .createMerchItem(item)
      .write();

    const merchStoreController = ControllerFactory.merchStore(conn);

    // delete all options from the merch item
    for (let i = 0; i < item.options.length; i += 1) {
      const optionParams = { uuid: item.options[i].uuid };
      await merchStoreController.deleteMerchItemOption(optionParams, admin);
    }

    const itemParams = { uuid: item.uuid };
    let getMerchItemResponse = await merchStoreController.getOneMerchItem(itemParams, admin);
    expect(getMerchItemResponse.item.options).toHaveLength(0);

    // add back the same options
    for (let i = 0; i < item.options.length; i += 1) {
      const createMerchItemOptionRequest = { option: item.options[i] };
      await merchStoreController.createMerchItemOption(itemParams, createMerchItemOptionRequest, admin);
    }

    getMerchItemResponse = await merchStoreController.getOneMerchItem(itemParams, admin);
    expect(getMerchItemResponse.item.options).toHaveLength(item.options.length);
  });

  test('cannot delete all item options if the item is visible', async () => {
    const conn = await DatabaseConnection.get();
    const admin = UserFactory.fake({ accessType: UserAccessType.ADMIN });
    const item = MerchFactory.fakeItem({ hidden: false });

    await new PortalState()
      .createUsers(admin)
      .createMerchItem(item)
      .write();

    const merchStoreController = ControllerFactory.merchStore(conn);

    // delete all but one options from the merch item
    for (let i = 1; i < item.options.length; i += 1) {
      const optionParams = { uuid: item.options[i].uuid };
      await merchStoreController.deleteMerchItemOption(optionParams, admin);
    }

    // should fail to delete the only remaining option
    await expect(merchStoreController.deleteMerchItemOption({ uuid: item.options[0].uuid }, admin))
      .rejects.toThrow('Cannot delete the only option for a visible merch item');

    const itemParams = { uuid: item.uuid };
    const getMerchItemResponse = await merchStoreController.getOneMerchItem(itemParams, admin);
    expect(getMerchItemResponse.item.options).toHaveLength(1);
  });

  test('cannot update an item with no options to be visible', async () => {
    const conn = await DatabaseConnection.get();
    const admin = UserFactory.fake({ accessType: UserAccessType.ADMIN });
    const item = MerchFactory.fakeItem({
      hidden: true,
      hasVariantsEnabled: true,
      options: [],
    });

    await new PortalState()
      .createUsers(admin)
      .createMerchItem(item)
      .write();

    const params = { uuid: item.uuid };
    const editMerchItemRequest = { merchandise: { hidden: false } };
    await expect(ControllerFactory.merchStore(conn).editMerchItem(params, editMerchItemRequest, admin))
      .rejects.toThrow('Item cannot be set to visible if it has 0 options.');
  });
});

describe('merch item edits', () => {
  test('merch item fields can be updated', async () => {
    const conn = await DatabaseConnection.get();
    const admin = UserFactory.fake({ accessType: UserAccessType.ADMIN });
    const item = MerchFactory.fakeItem();

    await new PortalState()
      .createUsers(admin)
      .createMerchItem(item)
      .write();

    const merchStoreController = ControllerFactory.merchStore(conn);
    const params = { uuid: item.uuid };

    // update the description and increment the purchase limits
    const merchItemEdits: MerchItemEdit = {
      description: faker.datatype.hexaDecimal(10),
      monthlyLimit: item.monthlyLimit + 1,
      lifetimeLimit: item.lifetimeLimit + 1,
    };
    const editMerchItemRequest = { merchandise: merchItemEdits };
    await merchStoreController.editMerchItem(params, editMerchItemRequest, admin);

    const getMerchItemResponse = await merchStoreController.getOneMerchItem(params, admin);
    expect(getMerchItemResponse.item.description).toEqual(merchItemEdits.description);
    expect(getMerchItemResponse.item.monthlyLimit).toEqual(merchItemEdits.monthlyLimit);
    expect(getMerchItemResponse.item.lifetimeLimit).toEqual(merchItemEdits.lifetimeLimit);
  });

  test('merch item option fields can be updated', async () => {
    const conn = await DatabaseConnection.get();
    const admin = UserFactory.fake({ accessType: UserAccessType.ADMIN });
    const item = MerchFactory.fakeItem({ hasVariantsEnabled: true });

    await new PortalState()
      .createUsers(admin)
      .createMerchItem(item)
      .write();

    const merchStoreController = ControllerFactory.merchStore(conn);
    const params = { uuid: item.uuid };

    // make small updates to all the options in an item
    const optionUpdates = item.options.map((o) => ({
      uuid: o.uuid,
      price: o.price + 50,
      quantityToAdd: 5,
      discountPercentage: o.discountPercentage + 5,
    }));

    const editMerchItemRequest = { merchandise: { options: optionUpdates } };
    await merchStoreController.editMerchItem(params, editMerchItemRequest, admin);

    // combine the original options and their updates
    const updatedOptions = zip(item.options, optionUpdates).map(([original, update]) => ({
      uuid: original.uuid,
      quantity: original.quantity + update.quantityToAdd,
      price: update.price,
      discountPercentage: update.discountPercentage,
      metadata: original.metadata,
    }));

    const getMerchItemResponse = await merchStoreController.getOneMerchItem(params, admin);
    expect(getMerchItemResponse.item.options)
      .toEqual(expect.arrayContaining(updatedOptions));
  });

  test('merch item option quantity can be incremented and decremented', async () => {
    const conn = await DatabaseConnection.get();
    const admin = UserFactory.fake({ accessType: UserAccessType.ADMIN });
    const option = MerchFactory.fakeOption({
      quantity: 10,
    });
    const item = MerchFactory.fakeItem({
      hasVariantsEnabled: false,
      options: [option],
    });

    await new PortalState()
      .createUsers(admin)
      .createMerchItem(item)
      .write();

    const merchStoreController = ControllerFactory.merchStore(conn);
    const params = { uuid: item.uuid };

    // increment quantity from 10 to 15
    const incrementOptionUpdates = [{
      uuid: option.uuid,
      quantityToAdd: 5,
    }];
    const incrementQuantityRequest = { merchandise: { options: incrementOptionUpdates } };
    await merchStoreController.editMerchItem(params, incrementQuantityRequest, admin);

    // verify it got incremented
    const incrementedQuantityResponse = await merchStoreController.getOneMerchItem(params, admin);
    const incrementedOption = incrementedQuantityResponse.item.options[0];
    expect(incrementedOption.quantity).toEqual(15);

    // decrement quantity from 15 to 10
    const decrementOptionUpdates = [{
      uuid: option.uuid,
      quantityToAdd: -5,
    }];
    const decrementQuantityRequest = { merchandise: { options: decrementOptionUpdates } };
    await merchStoreController.editMerchItem(params, decrementQuantityRequest, admin);

    // verify it got decremented
    const decrementedQuantityResponse = await merchStoreController.getOneMerchItem(params, admin);
    const decrementedOption = decrementedQuantityResponse.item.options[0];
    expect(decrementedOption.quantity).toEqual(10);
  });

  test('merch item option quantity cannot be decremented to below 0', async () => {
    const conn = await DatabaseConnection.get();
    const admin = UserFactory.fake({ accessType: UserAccessType.ADMIN });
    const option = MerchFactory.fakeOption({
      quantity: 5,
    });
    const item = MerchFactory.fakeItem({
      hasVariantsEnabled: false,
      options: [option],
    });

    await new PortalState()
      .createUsers(admin)
      .createMerchItem(item)
      .write();

    const merchStoreController = ControllerFactory.merchStore(conn);
    const params = { uuid: item.uuid };

    // decrement quantity by 10 when the current quantity is 5
    const decrementOptionUpdates = [{
      uuid: option.uuid,
      quantityToAdd: -10,
    }];
    const decrementQuantityRequest = { merchandise: { options: decrementOptionUpdates } };
    expect(merchStoreController.editMerchItem(params, decrementQuantityRequest, admin))
      .rejects.toThrow(`Cannot decrement option quantity below 0 for option: ${option.uuid}`);
  });

  test('items cannot be updated to have multiple options with different types', async () => {
    const conn = await DatabaseConnection.get();
    const admin = UserFactory.fake({ accessType: UserAccessType.ADMIN });
    const item = MerchFactory.fakeItem({ hasVariantsEnabled: true });

    await new PortalState()
      .createUsers(admin)
      .createMerchItem(item)
      .write();

    // change only one option's type to a different one
    item.options[0].metadata.type = faker.datatype.hexaDecimal(10);

    const params = { uuid: item.uuid };
    const editMerchItemRequest = { merchandise: { options: item.options } };
    await expect(ControllerFactory.merchStore(conn).editMerchItem(params, editMerchItemRequest, admin))
      .rejects.toThrow('Merch items cannot have multiple option types');
  });

  test('items can have their options\' types updated as long as its the same type for all options', async () => {
    const conn = await DatabaseConnection.get();
    const admin = UserFactory.fake({ accessType: UserAccessType.ADMIN });
    const item = MerchFactory.fakeItem({ hasVariantsEnabled: true });

    await new PortalState()
      .createUsers(admin)
      .createMerchItem(item)
      .write();

    const merchStoreController = ControllerFactory.merchStore(conn);
    const params = { uuid: item.uuid };

    // change every option's type to a different but consistent one
    const type = faker.datatype.hexaDecimal(10);
    const updatedOptions = item.options.map((o) => MerchandiseItemOptionModel.merge(o, {
      metadata: {
        type,
        position: o.metadata.position,
        value: o.metadata.value,
      },
    }));

    const editMerchItemRequest = { merchandise: { options: updatedOptions } };
    await merchStoreController.editMerchItem(params, editMerchItemRequest, admin);
    const merchItemResponse = await merchStoreController.getOneMerchItem(params, admin);

    const publicUpdatedOptions = updatedOptions.map((o) => o.getPublicMerchItemOption());
    expect(merchItemResponse.item.options)
      .toEqual(expect.arrayContaining(publicUpdatedOptions));
  });
});

describe('merch item option variants', () => {
  test('items cannot have variants disabled and have multiple options', async () => {
    const conn = await DatabaseConnection.get();
    const admin = UserFactory.fake({ accessType: UserAccessType.ADMIN });
    const item = MerchFactory.fakeItem({ hasVariantsEnabled: true });

    await new PortalState()
      .createUsers(admin)
      .createMerchItem(item)
      .write();

    const params = { uuid: item.uuid };
    const editMerchItemRequest = { merchandise: { hasVariantsEnabled: false } };
    await expect(ControllerFactory.merchStore(conn).editMerchItem(params, editMerchItemRequest, admin))
      .rejects.toThrow('Merch items with variants disabled cannot have multiple options');
  });

  test('items cannot have variants enabled and have null metadata for an option', async () => {
    const conn = await DatabaseConnection.get();
    const admin = UserFactory.fake({ accessType: UserAccessType.ADMIN });
    const item = MerchFactory.fakeItem({ hasVariantsEnabled: false });

    await new PortalState()
      .createUsers(admin)
      .createMerchItem(item)
      .write();

    const merchStoreController = ControllerFactory.merchStore(conn);
    const params = { uuid: item.uuid };

    const editMerchItemRequest = { merchandise: { hasVariantsEnabled: true } };
    await expect(merchStoreController.editMerchItem(params, editMerchItemRequest, admin))
      .rejects.toThrow('Merch options for items with variants enabled must have valid metadata');
  });
});

describe('merch item options', () => {
  test('can add options with some type to an item with variants enabled and options of the same type', async () => {
    const conn = await DatabaseConnection.get();
    const admin = UserFactory.fake({ accessType: UserAccessType.ADMIN });
    const item = MerchFactory.fakeItem({ hasVariantsEnabled: true });

    await new PortalState()
      .createUsers(admin)
      .createMerchItem(item)
      .write();

    const merchStoreController = ControllerFactory.merchStore(conn);
    const params = { uuid: item.uuid };

    // create and add option with same type as existing options
    const optionWithSameType = MerchFactory.fakeOptionWithType(item.options[0].metadata.type);
    const createMerchOptionRequest = { option: optionWithSameType };
    await merchStoreController.createMerchItemOption(params, createMerchOptionRequest, admin);

    const merchItemResponse = await merchStoreController.getOneMerchItem(params, admin);

    // verify that option was added
    const existingPublicOptions = item.options.map((o) => o.getPublicMerchItemOption());
    const allOptions = [
      ...existingPublicOptions,
      optionWithSameType.getPublicMerchItemOption(),
    ];
    expect(merchItemResponse.item.options).toEqual(expect.arrayContaining(allOptions));
  });

  test('cannot add options with some type to an item with variants enabled but options of another type', async () => {
    const conn = await DatabaseConnection.get();
    const admin = UserFactory.fake({ accessType: UserAccessType.ADMIN });
    const item = MerchFactory.fakeItem({ hasVariantsEnabled: true });

    await new PortalState()
      .createUsers(admin)
      .createMerchItem(item)
      .write();

    const optionWithDifferentType = MerchFactory.fakeOptionWithType(faker.datatype.hexaDecimal(10));

    const params = { uuid: item.uuid };
    const createMerchOptionRequest = { option: optionWithDifferentType };
    await expect(ControllerFactory.merchStore(conn).createMerchItemOption(params, createMerchOptionRequest, admin))
      .rejects.toThrow('Merch items cannot have multiple option types');
  });

  test('can delete option of some type from item with variants disabled and add option of another type', async () => {
    const conn = await DatabaseConnection.get();
    const admin = UserFactory.fake({ accessType: UserAccessType.ADMIN });
    const item = MerchFactory.fakeItem({
      hasVariantsEnabled: false,
      hidden: true,
    });

    await new PortalState()
      .createUsers(admin)
      .createMerchItem(item)
      .write();

    const merchStoreController = ControllerFactory.merchStore(conn);
    const optionParams = { uuid: item.options[0].uuid };
    const itemParams = { uuid: item.uuid };

    // delete original option from item
    await merchStoreController.deleteMerchItemOption(optionParams, admin);

    // add option of another type
    const optionWithDifferentType = MerchFactory.fakeOptionWithType(faker.datatype.hexaDecimal(10));
    const createMerchOptionRequest = { option: optionWithDifferentType };
    await merchStoreController.createMerchItemOption(itemParams, createMerchOptionRequest, admin);

    const merchItemResponse = await merchStoreController.getOneMerchItem(itemParams, admin);
    expect(merchItemResponse.item.options).toHaveLength(1);
    expect(merchItemResponse.item.options[0])
      .toStrictEqual(optionWithDifferentType.getPublicMerchItemOption());
  });

  test('cannot add option to an item with variants disabled and an option', async () => {
    const conn = await DatabaseConnection.get();
    const admin = UserFactory.fake({ accessType: UserAccessType.ADMIN });
    const item = MerchFactory.fakeItem({ hasVariantsEnabled: false });

    await new PortalState()
      .createUsers(admin)
      .createMerchItem(item)
      .write();

    const merchStoreController = ControllerFactory.merchStore(conn);
    const params = { uuid: item.uuid };

    const createMerchOptionRequest = { option: MerchFactory.fakeOption() };
    await expect(merchStoreController.createMerchItemOption(params, createMerchOptionRequest, admin))
      .rejects.toThrow('Merch items with variants disabled cannot have multiple options');

    const getMerchItemResponse = await merchStoreController.getOneMerchItem(params, admin);
    expect(getMerchItemResponse.item.options).toHaveLength(1);
    expect(getMerchItemResponse.item.options[0])
      .toStrictEqual(item.options[0].getPublicMerchItemOption());
  });
});

describe('checkout cart', () => {
  test('passing in valid item option uuids returns the full options and their items', async () => {
    const conn = await DatabaseConnection.get();
    const member = UserFactory.fake();
    const option1 = MerchFactory.fakeOption();
    const option2 = MerchFactory.fakeOption();
    const option3 = MerchFactory.fakeOption();
    const options = [option1, option2, option3];

    const itemForOptions1And2 = MerchFactory.fakeItem({ options: [option1, option2] });
    const itemForOption3 = MerchFactory.fakeItem({ options: [option3] });

    // need to explicitly set option.item after calling fakeItem(),
    // so that the item.options elements don't have circular references to
    // the item, but the singular option objects here do
    // (so that option.getPublicCartMerchItemOption() doesn't throw for undefined item)
    option1.item = itemForOptions1And2;
    option2.item = itemForOptions1And2;
    option3.item = itemForOption3;

    await new PortalState()
      .createUsers(member)
      .createMerchItem(itemForOptions1And2)
      .createMerchItem(itemForOption3)
      .write();

    const params = { items: options.map((o) => o.uuid) };
    const merchStoreController = ControllerFactory.merchStore(conn);
    const getCartResponse = await merchStoreController.getCartItems(params, member);

    const { cart } = getCartResponse;

    expect(cart).toHaveLength(3);
    expect(cart[0]).toStrictEqual(option1.getPublicOrderMerchItemOption());
    expect(cart[1]).toStrictEqual(option2.getPublicOrderMerchItemOption());
    expect(cart[2]).toStrictEqual(option3.getPublicOrderMerchItemOption());
  });

  test('passing in item option uuids that do not exist throws an error', async () => {
    const conn = await DatabaseConnection.get();
    const member = UserFactory.fake();
    const option1 = MerchFactory.fakeOption();
    const option2 = MerchFactory.fakeOption();
    const options = [option1, option2];

    const item = MerchFactory.fakeItem({ options: [option1, option2] });

    await new PortalState()
      .createUsers(member)
      .createMerchItem(item)
      .write();

    const validOptionUuids = options.map((o) => o.uuid);
    const invalidOptionUuid = faker.datatype.uuid();
    const params = { items: [...validOptionUuids, invalidOptionUuid] };
    const merchStoreController = ControllerFactory.merchStore(conn);
    expect(merchStoreController.getCartItems(params, member))
      .rejects.toThrow(`The following items were not found: ${[invalidOptionUuid]}`);
  });
});
